<!DOCTYPE html>
<html>
<head>
    <title>Void Harmonic Studio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0b0908;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'UnifrakturMaguntia', cursive;
            color: #b0946e;
        }
        .controls {
            position: fixed;
            top: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #3a2525;
            box-shadow: 0 0 15px #3a252544;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 15px;
            background: #2a1515;
            border: 1px solid #5e2a2a;
            color: #b0946e;
            cursor: pointer;
            font-family: 'UnifrakturMaguntia', cursive;
            transition: all 0.3s;
            letter-spacing: 1px;
        }
        button:hover {
            background: #3a2525;
            text-shadow: 0 0 8px #b0946eaa;
        }
        .piano {
            position: fixed;
            bottom: 30px;
            background: #1a1010dd;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #3a2525;
            backdrop-filter: blur(3px);
            box-shadow: 0 0 30px #00000066;
            z-index: 101;
        }
        .key {
            display: inline-block;
            width: 50px;
            height: 180px;
            margin: 0 2px;
            background: #1a0a0a;
            border: 1px solid #3a2525;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }
        .key.black {
            background: #0a0505;
            height: 110px;
            width: 34px;
            margin: 0 -17px;
            z-index: 2;
        }
        .key.active {
            background: #3a2525 !important;
            box-shadow: inset 0 0 15px #b0946e33;
        }
        .key-label {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #b0946e;
            font-size: 0.8em;
        }
        canvas {
            filter: sepia(0.3) contrast(1.2) brightness(0.8);
        }
        .loop-controls {
            position: fixed;
            right: 20px;
            top: 20px;
            background: #1a1010dd;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #3a2525;
            backdrop-filter: blur(3px);
            box-shadow: 0 0 30px #00000066;
            z-index: 102;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .cathedral-overlay {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: 
                radial-gradient(circle at 50% 50%, transparent 60%, rgba(0,0,0,0.9)),
                repeating-linear-gradient(0deg, transparent 0px, rgba(90,30,30,0.1) 3px, transparent 6px);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
</head>
<body>
    <div class="controls">
        <button onclick="playDarkProgression()">Summon Darkness</button>
        <button onclick="clearAll()">Silence</button>
    </div>

    <div class="loop-controls">
        <button onclick="startLoop()">Begin Ritual</button>
        <button onclick="stopLoop()">Cease Ritual</button>
        <button onclick="toggleReverb()" id="reverbBtn">Reverb: On</button>
    </div>

    <div class="piano" id="piano"></div>
    <canvas id="canvas"></canvas>
    <div class="cathedral-overlay"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioContext, activeOscillators = new Map();
        let loopIntervals = [];
        let loopNotes = [];
        let reverbEnabled = true;
        let reverbNode, delayNode, distortionNode, mainGain;
        const NOTE_FREQS = {
            'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
            'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
            'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
        };

        // Initialize piano
        const pianoKeys = [
            {note: 'C', black: false}, {note: 'C#', black: true}, 
            {note: 'D', black: false}, {note: 'D#', black: true},
            {note: 'E', black: false}, {note: 'F', black: false},
            {note: 'F#', black: true}, {note: 'G', black: false},
            {note: 'G#', black: true}, {note: 'A', black: false},
            {note: 'A#', black: true}, {note: 'B', black: false}
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const pianoElem = document.getElementById('piano');
            pianoKeys.forEach(keyData => {
                const key = document.createElement('div');
                key.className = `key${keyData.black ? ' black' : ''}`;
                key.dataset.note = keyData.note;
                const label = document.createElement('div');
                label.className = 'key-label';
                label.textContent = keyData.note;
                key.appendChild(label);
                
                key.addEventListener('mousedown', () => {
                    key.classList.add('active');
                    playNote(keyData.note);
                    loopNotes.push(keyData.note);
                });
                
                key.addEventListener('mouseup', () => {
                    key.classList.remove('active');
                    stopNote(keyData.note);
                });
                
                key.addEventListener('mouseleave', () => {
                    key.classList.remove('active');
                    stopNote(keyData.note);
                });
                
                pianoElem.appendChild(key);
            });
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        async function setupAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mainGain = audioContext.createGain();
                mainGain.gain.value = 0.7;
                
                // Create effect nodes
                reverbNode = audioContext.createConvolver();
                delayNode = audioContext.createDelay();
                distortionNode = audioContext.createWaveShaper();
                const limiter = audioContext.createDynamicsCompressor();
                
                // Configure effects
                delayNode.delayTime.value = 1.2;
                distortionNode.curve = makeDistortionCurve(150);
                distortionNode.oversample = '4x';
                
                // Connect effect chain
                mainGain.connect(delayNode);
                delayNode.connect(reverbNode);
                reverbNode.connect(distortionNode);
                distortionNode.connect(limiter);
                limiter.connect(audioContext.destination);

                // Load cathedral impulse response
                try {
                    const response = await fetch('https://cdn.rawgit.com/hoch/impulse-responses/master/Altiverb%20IR%20Files/Cathedrals/Chartres%20Cathedral.ogg');
                    const buffer = await response.arrayBuffer();
                    reverbNode.buffer = await audioContext.decodeAudioData(buffer);
                } catch (error) {
                    console.error('Error loading reverb:', error);
                }
            }
        }

        function makeDistortionCurve(amount) {
            const curve = new Float32Array(44100);
            for (let i = 0; i < curve.length; i++) {
                const x = (i * 2) / curve.length - 1;
                curve[i] = Math.tanh(x * amount * 0.08);
            }
            return curve;
        }

        function toggleReverb() {
            reverbEnabled = !reverbEnabled;
            document.getElementById('reverbBtn').textContent = `Reverb: ${reverbEnabled ? 'On' : 'Off'}`;
            reverbNode.disconnect();
            if (reverbEnabled) {
                delayNode.connect(reverbNode);
            } else {
                delayNode.connect(distortionNode);
            }
        }

        function playNote(note) {
            setupAudio().then(() => {
                if (!activeOscillators.has(note)) {
                    const freq = NOTE_FREQS[note];
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const pan = audioContext.createStereoPanner();
                    const filter = audioContext.createBiquadFilter();

                    // Dark sound parameters
                    osc.type = ['square', 'sawtooth'][Math.floor(Math.random() * 2)];
                    osc.frequency.setValueAtTime(freq * (0.95 + Math.random() * 0.1), audioContext.currentTime);
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 600 + Math.random() * 800;
                    filter.Q.value = 12;
                    
                    gain.gain.value = 0.35;
                    pan.pan.value = Math.random() * 2 - 1;

                    // Connect nodes
                    osc.connect(filter)
                       .connect(gain)
                       .connect(pan)
                       .connect(mainGain);

                    osc.start();

                    activeOscillators.set(note, { 
                        osc, gain, pan, filter,
                        freq,
                        hue: (freq * 0.5) % 360,
                        size: mapRange(freq, 261, 494, 40, 60),
                        speed: mapRange(freq, 261, 494, 0.5, 1.2),
                        symbol: getSymbol(freq)
                    });
                }
            });
        }

        function stopNote(note) {
            if (activeOscillators.has(note)) {
                const { osc, gain } = activeOscillators.get(note);
                gain.gain.setValueAtTime(gain.gain.value, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);
                setTimeout(() => {
                    osc.stop();
                    osc.disconnect();
                }, 1200);
                activeOscillators.delete(note);
            }
        }

        function playDarkProgression() {
            const demonChords = [
                ['C', 'F#', 'D#'], 
                ['G#', 'C', 'E', 'A#'],
                ['D', 'F', 'A#', 'B'],
                ['B', 'E', 'G', 'C#']
            ];
            const chord = demonChords[Math.floor(Math.random() * demonChords.length)];
            chord.forEach(note => playNote(note));
        }

        function clearAll() {
            activeOscillators.forEach(({ osc }) => osc.stop());
            activeOscillators.clear();
            document.querySelectorAll('.key').forEach(k => k.classList.remove('active'));
        }

        function startLoop() {
            const interval = setInterval(() => {
                loopNotes.forEach(note => playNote(note));
            }, 3000);
            loopIntervals.push(interval);
        }

        function stopLoop() {
            loopIntervals.forEach(clearInterval);
            loopIntervals = [];
        }

        function mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }

        function getSymbol(freq) {
            const symbols = ['eye', 'thorn', 'crescent', 'skull', 'gate'];
            return symbols[Math.floor(mapRange(freq, 261, 494, 0, symbols.length-1))];
        }

        function animate() {
            ctx.fillStyle = 'rgba(11, 9, 8, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const time = Date.now() / 1000;
            const centerX = canvas.width/2;
            const centerY = canvas.height/2;

            activeOscillators.forEach(({ symbol, freq, hue, size, speed }, note) => {
                const angle = time * speed;
                const radius = mapRange(freq, 261, 494, 200, 400);
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.strokeStyle = `hsla(${hue}, 70%, 30%, 0.9)`;
                ctx.fillStyle = `hsla(${(hue + 180) % 360}, 50%, 10%, 0.3)`;
                ctx.lineWidth = 2;

                switch(symbol) {
                    case 'eye':
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, size/4, 0, Math.PI*2);
                        ctx.fill();
                        break;
                    case 'thorn':
                        ctx.beginPath();
                        ctx.moveTo(-size/2, size/2);
                        ctx.lineTo(size/2, -size/2);
                        ctx.lineTo(0, size/2);
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'crescent':
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, Math.PI*0.25, Math.PI*1.75);
                        ctx.stroke();
                        break;
                }

                ctx.restore();
            });

            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
